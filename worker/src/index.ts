/**\n * FlickMV On-demand Worker with Watermark Support (TypeScript)\n * - Single-run worker: fetches at most one job from pg-boss and exits (suitable for Cloud Run Jobs)\n * - Generates a placeholder video via ffmpeg with FlickMV watermark based on user plan\n * - Applies watermark settings from export job metadata\n * - Optionally uploads result to Cloudflare R2 (S3-compatible) if credentials are provided\n * - Reports progress and final status to server internal API with x-internal-key\n */\n\nimport PgBoss from 'pg-boss';\nimport ffmpeg from 'fluent-ffmpeg';\nimport fs from 'fs';\nimport fsp from 'fs/promises';\nimport path from 'path';\nimport os from 'os';\nimport { S3Client, PutObjectCommand } from '@aws-sdk/client-s3';\nimport { Upload } from '@aws-sdk/lib-storage';\nimport dotenv from 'dotenv';\nimport winston from 'winston';\nimport { v4 as uuidv4 } from 'uuid';\nimport axios from 'axios';\nimport tmp from 'tmp';\n\n// Load environment variables\ndotenv.config();\n\n// Types\ninterface WatermarkSettings {\n  enabled: boolean;\n  preset: 'minimal' | 'branded' | 'corner' | 'center';\n}\n\ninterface WatermarkPreset {\n  position: { x: number; y: number };\n  size: number;\n  opacity: number;\n  style: string;\n}\n\ninterface ExportJob {\n  id: string;\n  name?: string;\n  userId: string;\n  metadata?: {\n    timeline?: {\n      duration?: number;\n    };\n  };\n  output?: {\n    duration?: number;\n  };\n  watermarkSettings?: WatermarkSettings;\n}\n\ninterface JobData {\n  exportJobId: string;\n}\n\ninterface JobDetail {\n  success: boolean;\n  data: {\n    exportJob: ExportJob;\n  };\n}\n\ninterface APIResponse {\n  success: boolean;\n  message?: string;\n  error?: string;\n  data?: any;\n}\n\ninterface StorageInfo {\n  provider: 'local' | 's3';\n  bucket?: string;\n  key?: string;\n}\n\ninterface OutputInfo {\n  url?: string;\n  filename: string;\n  size: number;\n  duration: number;\n  storage: StorageInfo;\n  watermark: {\n    applied: boolean;\n    preset: string;\n    timestamp: string;\n  };\n}\n\ninterface ErrorInfo {\n  message: string;\n  stack?: string;\n  timestamp: string;\n}\n\n// Configuration\nconst LOG_LEVEL = process.env.LOG_LEVEL || 'info';\n\n// Logger setup\nconst logger = winston.createLogger({\n  level: LOG_LEVEL,\n  format: winston.format.combine(\n    winston.format.timestamp(),\n    winston.format.colorize(),\n    winston.format.printf(({ timestamp, level, message, ...meta }) => {\n      return `${timestamp} [${level}]: ${message} ${Object.keys(meta).length ? JSON.stringify(meta, null, 2) : ''}`;\n    })\n  ),\n  transports: [\n    new winston.transports.Console()\n  ]\n});\n\n// Watermark presets matching the server-side configuration\nconst WATERMARK_PRESETS: Record<string, WatermarkPreset> = {\n  minimal: {\n    position: { x: 85, y: 10 },\n    size: 12,\n    opacity: 60,\n    style: 'minimal'\n  },\n  branded: {\n    position: { x: 50, y: 50 },\n    size: 25,\n    opacity: 30,\n    style: 'branded'\n  },\n  corner: {\n    position: { x: 90, y: 90 },\n    size: 15,\n    opacity: 70,\n    style: 'corner'\n  },\n  center: {\n    position: { x: 50, y: 85 },\n    size: 18,\n    opacity: 50,\n    style: 'center'\n  }\n};\n\n// Environment validation\nfunction required(name: string): string {\n  const val = process.env[name];\n  if (!val) {\n    throw new Error(`Missing required environment variable: ${name}`);\n  }\n  return val;\n}\n\nfunction getEnv(name: string, defaultValue: string): string {\n  const val = process.env[name];\n  return val !== undefined ? val : defaultValue;\n}\n\n/**\n * Generate FFmpeg watermark filter based on settings\n */\nfunction generateWatermarkFilter(\n  watermarkSettings: WatermarkSettings | undefined,\n  videoWidth: number = 1080,\n  videoHeight: number = 1920\n): string | null {\n  if (!watermarkSettings || !watermarkSettings.enabled) {\n    return null;\n  }\n\n  const preset = WATERMARK_PRESETS[watermarkSettings.preset] || WATERMARK_PRESETS.minimal;\n  \n  // Calculate absolute position from percentage\n  const x = Math.round((preset.position.x / 100) * videoWidth);\n  const y = Math.round((preset.position.y / 100) * videoHeight);\n  \n  // Calculate font size based on video resolution and preset size\n  const fontSize = Math.round((preset.size / 720) * videoHeight * 0.05);\n  \n  // Base text filter\n  let textFilter = `drawtext=text='FlickMV':fontcolor=white:fontsize=${fontSize}:x=${x}:y=${y}:alpha=${preset.opacity / 100}`;\n  \n  // Add style-specific modifications\n  switch (preset.style) {\n    case 'minimal':\n      textFilter += ':shadowcolor=black:shadowx=1:shadowy=1';\n      break;\n    case 'branded':\n      textFilter += ':fontcolor=0x6366f1:borderw=1:bordercolor=white';\n      break;\n    case 'corner':\n      textFilter += ':box=1:boxcolor=black@0.6:boxborderw=5';\n      break;\n    case 'center':\n      textFilter += ':box=1:boxcolor=black@0.4:boxborderw=10:borderw=1:bordercolor=white@0.3';\n      break;\n  }\n\n  return textFilter;\n}\n\n/**\n * Create temporary directory with cleanup\n */\nasync function createTempDirectory(): Promise<{ path: string; cleanup: () => Promise<void> }> {\n  const tmpDir = await fsp.mkdtemp(path.join(os.tmpdir(), 'flickmv-'));\n  \n  return {\n    path: tmpDir,\n    cleanup: async () => {\n      try {\n        await fsp.rm(tmpDir, { recursive: true, force: true });\n        logger.debug(`Cleaned up temp directory: ${tmpDir}`);\n      } catch (error) {\n        logger.warn(`Failed to cleanup temp directory ${tmpDir}:`, error);\n      }\n    }\n  };\n}\n\n/**\n * Sanitize filename for safe filesystem use\n */\nfunction sanitizeFilename(name: string): string {\n  return String(name)\n    .replace(/[^a-zA-Z0-9_\\-\\.]+/g, '_')\n    .slice(0, 80);\n}\n\n/**\n * Escape text for FFmpeg drawtext filter\n */\nfunction escapeText(text: string): string {\n  return String(text)\n    .replace(/:/g, '\\\\:')\n    .replace(/'/g, \"\\\\\\\\'\") \n    .replace(/,/g, '\\\\,');\n}\n\n/**\n * Render video with watermark using FFmpeg\n */\nfunction renderVideoWithWatermark(\n  outPath: string,\n  durationSec: number,\n  watermarkSettings?: WatermarkSettings\n): Promise<void> {\n  return new Promise((resolve, reject) => {\n    const videoWidth = 1080;\n    const videoHeight = 1920;\n    \n    // Generate watermark filter\n    const watermarkFilter = generateWatermarkFilter(watermarkSettings, videoWidth, videoHeight);\n    \n    // Base content text\n    const contentText = 'FlickMV Export Demo';\n    let videoFilters = `drawtext=text='${escapeText(contentText)}':fontcolor=white:fontsize=42:x=(w-text_w)/2:y=(h-text_h)/2:box=1:boxcolor=black@0.4:boxborderw=20`;\n    \n    // Add watermark filter if enabled\n    if (watermarkFilter) {\n      videoFilters += `,${watermarkFilter}`;\n      logger.info(`Applying watermark: ${watermarkSettings?.preset}`);\n    } else {\n      logger.info('No watermark applied');\n    }\n\n    const ffmpegCommand = ffmpeg()\n      .input(`color=c=black:s=${videoWidth}x${videoHeight}:d=${durationSec}`)\n      .inputFormat('lavfi')\n      .videoCodec('libx264')\n      .fps(30)\n      .outputOptions([\n        '-pix_fmt yuv420p',\n        '-movflags +faststart',\n        `-vf ${videoFilters}`\n      ])\n      .on('start', (cmd: string) => {\n        logger.debug('FFmpeg command:', cmd);\n      })\n      .on('progress', (progress: { percent?: number }) => {\n        if (progress.percent) {\n          logger.debug(`Rendering progress: ${Math.round(progress.percent)}%`);\n        }\n      })\n      .on('error', (err: Error) => {\n        logger.error('FFmpeg error:', err.message);\n        reject(err);\n      })\n      .on('end', () => {\n        logger.info('Video rendering completed');\n        resolve();\n      });\n\n    ffmpegCommand.save(outPath);\n  });\n}\n\n/**\n * Upload file to R2 storage\n */\nasync function uploadToR2(\n  filePath: string,\n  bucket: string,\n  key: string,\n  endpoint: string\n): Promise<void> {\n  const s3Client = new S3Client({\n    region: 'auto',\n    endpoint,\n    credentials: {\n      accessKeyId: required('R2_ACCESS_KEY_ID'),\n      secretAccessKey: required('R2_SECRET_ACCESS_KEY')\n    }\n  });\n\n  const fileStream = fs.createReadStream(filePath);\n  const upload = new Upload({\n    client: s3Client,\n    params: {\n      Bucket: bucket,\n      Key: key,\n      Body: fileStream,\n      ContentType: 'video/mp4'\n    }\n  });\n\n  await upload.done();\n  logger.info(`Upload completed to R2: ${bucket}/${key}`);\n}\n\n/**\n * Make internal API request\n */\nasync function internalRequest<T = APIResponse>(\n  method: 'GET' | 'POST',\n  url: string,\n  key: string,\n  data?: any\n): Promise<T> {\n  try {\n    const response = await axios({\n      method,\n      url,\n      headers: {\n        'x-internal-key': key,\n        'Content-Type': 'application/json'\n      },\n      data: data ? JSON.stringify(data) : undefined,\n      timeout: 30000\n    });\n\n    const responseData = response.data as APIResponse;\n    \n    if (!responseData.success) {\n      throw new Error(`Internal API error: ${responseData.message || responseData.error}`);\n    }\n\n    return responseData as T;\n  } catch (error) {\n    if (axios.isAxiosError(error)) {\n      throw new Error(`Internal API request failed: ${error.message}`);\n    }\n    throw error;\n  }\n}\n\n/**\n * Update export job status\n */\nasync function updateJobStatus(\n  internalBase: string,\n  internalKey: string,\n  exportJobId: string,\n  status?: string,\n  progress?: number,\n  output?: OutputInfo,\n  error?: ErrorInfo\n): Promise<void> {\n  const payload: any = {};\n  \n  if (status) payload.status = status;\n  if (progress !== undefined) payload.progress = progress;\n  if (output) payload.output = output;\n  if (error) payload.error = error;\n\n  await internalRequest(\n    'POST',\n    `${internalBase}/export/jobs/${exportJobId}/status`,\n    internalKey,\n    payload\n  );\n}\n\n/**\n * Main worker function\n */\nasync function main(): Promise<void> {\n  const connectionString = required('DATABASE_URL');\n  const internalBase = required('INTERNAL_API_BASE').replace(/\\/+$/, '');\n  const internalKey = required('INTERNAL_API_KEY');\n  const queueName = getEnv('EXPORT_QUEUE_NAME', 'video-export');\n\n  logger.info('Starting FlickMV Worker v1.2.0');\n\n  // Initialize pg-boss\n  const boss = new PgBoss({ \n    connectionString, \n    schema: process.env.PGBOSS_SCHEMA || undefined,\n    retryLimit: 3,\n    retryDelay: 30,\n    expireInSeconds: 900 // 15 minutes\n  });\n  \n  await boss.start();\n  logger.info('pg-boss started');\n\n  // Fetch one job (single-run)\n  const job = await boss.fetch(queueName);\n  if (!job) {\n    logger.info('No job available. Exiting.');\n    await boss.stop();\n    process.exit(0);\n    return;\n  }\n\n  logger.info(`Fetched job: ${job.id}`, { data: job.data });\n\n  const jobData = job.data as JobData;\n  const exportJobId = jobData?.exportJobId;\n  \n  if (!exportJobId) {\n    logger.error('Invalid job payload: missing exportJobId');\n    await boss.fail(job.id, new Error('Missing exportJobId'));\n    await boss.stop();\n    process.exit(1);\n    return;\n  }\n\n  const tempDir = await createTempDirectory();\n  \n  try {\n    // Pull full job details\n    logger.info(`Loading job details for export: ${exportJobId}`);\n    const jobDetail = await internalRequest<JobDetail>(\n      'GET',\n      `${internalBase}/export/jobs/${exportJobId}`,\n      internalKey\n    );\n    \n    logger.debug('Job detail loaded');\n\n    // Mark processing\n    await updateJobStatus(internalBase, internalKey, exportJobId, 'processing', 10);\n\n    // Extract job settings\n    const exportJob = jobDetail.data.exportJob;\n    const duration = Math.max(3, Math.min(600, \n      exportJob.metadata?.timeline?.duration || \n      exportJob.output?.duration || \n      10\n    ));\n    const watermarkSettings = exportJob.watermarkSettings || { enabled: true, preset: 'minimal' as const };\n    \n    logger.info(`Processing export job: duration=${duration}s, watermark=${watermarkSettings.enabled ? watermarkSettings.preset : 'disabled'}`);\n\n    // Update progress\n    await updateJobStatus(internalBase, internalKey, exportJobId, undefined, 25);\n\n    // Create output file\n    const filename = `${sanitizeFilename(exportJob.name || 'FlickMV_Export')}_${Date.now()}.mp4`;\n    const outPath = path.join(tempDir.path, filename);\n\n    logger.info(`Rendering video with watermark: ${outPath}`);\n\n    // Update progress\n    await updateJobStatus(internalBase, internalKey, exportJobId, undefined, 40);\n\n    // Render video with watermark\n    await renderVideoWithWatermark(outPath, duration, watermarkSettings);\n\n    // Update progress\n    await updateJobStatus(internalBase, internalKey, exportJobId, undefined, 70);\n\n    const stats = await fsp.stat(outPath);\n    logger.info(`Video rendered: ${stats.size} bytes`);\n\n    // Upload to R2 if configured\n    let downloadUrl: string | null = null;\n    let storage: StorageInfo = { provider: 'local' };\n    \n    const r2Endpoint = process.env.R2_ENDPOINT;\n    const r2Bucket = process.env.R2_BUCKET;\n    const r2Key = `exports/${String(exportJob.userId)}/${filename}`.replace(/\\\\/g, '/');\n    const publicBase = process.env.R2_PUBLIC_BASE_URL;\n\n    if (r2Endpoint && r2Bucket && process.env.R2_ACCESS_KEY_ID && process.env.R2_SECRET_ACCESS_KEY) {\n      logger.info(`Uploading to R2: ${r2Bucket}/${r2Key}`);\n      \n      // Update progress\n      await updateJobStatus(internalBase, internalKey, exportJobId, undefined, 80);\n\n      await uploadToR2(outPath, r2Bucket, r2Key, r2Endpoint);\n\n      if (publicBase) {\n        downloadUrl = `${publicBase.replace(/\\/+$/, '')}/${r2Key}`;\n      }\n\n      storage = { provider: 's3', bucket: r2Bucket, key: r2Key };\n      logger.info('Upload completed');\n    } else {\n      logger.info('R2 not configured, keeping local path only');\n    }\n\n    // Update progress\n    await updateJobStatus(internalBase, internalKey, exportJobId, undefined, 95);\n\n    // Prepare output info\n    const output: OutputInfo = {\n      url: downloadUrl || `/exports/${String(exportJob.userId)}/${filename}`,\n      filename,\n      size: stats.size,\n      duration,\n      storage,\n      watermark: {\n        applied: watermarkSettings.enabled,\n        preset: watermarkSettings.preset,\n        timestamp: new Date().toISOString()\n      }\n    };\n\n    // Report completion\n    await updateJobStatus(internalBase, internalKey, exportJobId, 'completed', 100, output);\n\n    await boss.complete(job.id);\n    logger.info(`Job completed: ${job.id}`);\n\n    await boss.stop();\n    process.exit(0);\n    \n  } catch (error) {\n    const err = error as Error;\n    logger.error('Worker error:', err.stack || err.message);\n    \n    try {\n      const errorInfo: ErrorInfo = {\n        message: err.message || String(err),\n        stack: err.stack,\n        timestamp: new Date().toISOString()\n      };\n      \n      await updateJobStatus(internalBase, internalKey, exportJobId, 'failed', 0, undefined, errorInfo);\n    } catch (reportError) {\n      logger.error('Failed to report failure to internal API:', reportError);\n    }\n    \n    try {\n      await boss.fail(job.id, err);\n    } catch (bossError) {\n      logger.error('Failed to mark job as failed in pg-boss:', bossError);\n    }\n    \n    await boss.stop();\n    process.exit(1);\n  } finally {\n    // Cleanup temporary directory\n    await tempDir.cleanup();\n  }\n}\n\n// Graceful shutdown handling\nprocess.on('SIGTERM', async () => {\n  logger.info('Received SIGTERM, shutting down gracefully');\n  process.exit(0);\n});\n\nprocess.on('SIGINT', async () => {\n  logger.info('Received SIGINT, shutting down gracefully');\n  process.exit(0);\n});\n\n// Unhandled promise rejection\nprocess.on('unhandledRejection', (reason, promise) => {\n  logger.error('Unhandled Rejection at:', promise, 'reason:', reason);\n  process.exit(1);\n});\n\n// Uncaught exception\nprocess.on('uncaughtException', (error) => {\n  logger.error('Uncaught Exception:', error);\n  process.exit(1);\n});\n\n// Start the worker\nmain().catch((error) => {\n  logger.error('Fatal error:', error);\n  process.exit(1);\n});\n