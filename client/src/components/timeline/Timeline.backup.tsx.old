import React, { useState, useRef, useEffect, useCallback } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { 
  Play, 
  Pause, 
  SkipBack, 
  SkipForward,
  Volume2,
  Scissors,
  Copy,
  Trash2,
  ZoomIn,
  ZoomOut,
  Music,
  Plus,
  ArrowRightLeft,
  Shuffle,
  Volume,
  Activity,
  Magnet,
  Zap
} from 'lucide-react';
import type { Timeline as TimelineType, TimelineClip, AudioTrack, Transition } from '@/types';
import WaveformDisplay from '../waveform/WaveformDisplay';

interface TimelineProps {
  timeline: TimelineType;
  playheadPosition: number;
  zoom: number;
  onClipSelect: (clip: TimelineClip) => void;
  onTimelineUpdate: (timeline: TimelineType) => void;
}

/**
 * ‰øÆÊ≠£Áâà„Çø„Ç§„É†„É©„Ç§„É≥ - „Ç∑„É≥„Éó„É´„ÅßÂÆâÂÆö„Åó„ÅüÂÆüË£Ö
 * - Ê®ôÊ∫ñÁöÑ„Å™„Éû„Ç¶„Çπ„Ç§„Éô„É≥„Éà„Çí‰ΩøÁî®
 * - „Éâ„É©„ÉÉ„Ç∞„Å®„É™„Çµ„Ç§„Ç∫„ÅÆÂàÜÈõ¢ÂÆüË£Ö
 * - „Éá„Éê„ÉÉ„Ç∞„Åó„ÇÑ„Åô„ÅÑ„Ç≥„Éº„ÉâÊßãÈÄ†
 */
const Timeline: React.FC<TimelineProps> = ({
  timeline,
  playheadPosition,
  zoom,
  onClipSelect,
  onTimelineUpdate
}) => {
  // ========== StateÁÆ°ÁêÜ ==========
  const [selectedClipId, setSelectedClipId] = useState<string | null>(null);
  const [copiedClip, setCopiedClip] = useState<TimelineClip | null>(null);
  const [dragState, setDragState] = useState<{
    isDragging: boolean;
    clipId: string | null;
    startX: number;
    startTime: number;
  }>({
    isDragging: false,
    clipId: null,
    startX: 0,
    startTime: 0
  });
  const [resizeState, setResizeState] = useState<{
    isResizing: boolean;
    clipId: string | null;
    edge: 'left' | 'right' | null;
    startX: number;
    originalStartTime: number;
    originalDuration: number;
  }>({
    isResizing: false,
    clipId: null,
    edge: null,
    startX: 0,
    originalStartTime: 0,
    originalDuration: 0
  });

  // ========== Refs ==========
  const timelineRef = useRef<HTMLDivElement>(null);
  const playheadRef = useRef<HTMLDivElement>(null);

  // ========== „Çπ„Ç±„Éº„É´Ë®àÁÆó ==========
  const basePixelsPerSecond = 40;
  const pixelsPerSecond = Math.max(10, Math.min(160, basePixelsPerSecond * zoom));
  
  const timeToPixel = useCallback((time: number) => {
    return time * pixelsPerSecond;
  }, [pixelsPerSecond]);
  
  const pixelToTime = useCallback((pixel: number) => {
    return pixel / pixelsPerSecond;
  }, [pixelsPerSecond]);

  // ========== „É¨„Ç§„Ç¢„Ç¶„ÉàÂÆöÊï∞ ==========
  const trackHeight = 60;
  const audioTrackHeight = 40;

  // ========== „Éâ„É©„ÉÉ„Ç∞Âá¶ÁêÜ ==========
  const handleClipMouseDown = useCallback((e: React.MouseEvent, clip: TimelineClip) => {
    e.preventDefault();
    e.stopPropagation();

    // „É™„Çµ„Ç§„Ç∫„Éè„É≥„Éâ„É´„Åå„ÇØ„É™„ÉÉ„ÇØ„Åï„Çå„ÅüÂ†¥Âêà„ÅØ„Éâ„É©„ÉÉ„Ç∞„Åó„Å™„ÅÑ
    const target = e.target as HTMLElement;
    if (target.classList.contains('resize-handle')) {
      return;
    }

    console.log(`üé¨ Starting drag for clip: ${clip.id}`);
    
    setSelectedClipId(clip.id);
    onClipSelect(clip);
    
    setDragState({
      isDragging: true,
      clipId: clip.id,
      startX: e.clientX,
      startTime: clip.startTime
    });

    // „Éû„Ç¶„Çπ„Ç´„Éº„ÇΩ„É´„ÇíÂ§âÊõ¥
    document.body.style.cursor = 'grabbing';
  }, [onClipSelect]);

  const handleMouseMove = useCallback((e: MouseEvent) => {
    if (dragState.isDragging && dragState.clipId && timelineRef.current) {
      const rect = timelineRef.current.getBoundingClientRect();
      const deltaX = e.clientX - dragState.startX;
      const newStartTime = Math.max(0, dragState.startTime + pixelToTime(deltaX));

      console.log(`üîÑ Dragging clip ${dragState.clipId} to time: ${newStartTime.toFixed(2)}s`);

      // „É™„Ç¢„É´„Çø„Ç§„É†„Åß‰ΩçÁΩÆ„ÇíÊõ¥Êñ∞
      const updatedClips = timeline.clips.map(clip =>
        clip.id === dragState.clipId
          ? { ...clip, startTime: newStartTime }
          : clip
      );

      onTimelineUpdate({
        ...timeline,
        clips: updatedClips
      });
    }

    if (resizeState.isResizing && resizeState.clipId && timelineRef.current) {
      const rect = timelineRef.current.getBoundingClientRect();
      const deltaX = e.clientX - resizeState.startX;
      const deltaTime = pixelToTime(deltaX);

      const clip = timeline.clips.find(c => c.id === resizeState.clipId);
      if (!clip) return;

      let updatedClip: TimelineClip;

      if (resizeState.edge === 'left') {
        // Â∑¶Á´Ø„ÅÆ„É™„Çµ„Ç§„Ç∫ - ÈñãÂßãÊôÇÈñì„Å®Èï∑„Åï„ÇíË™øÊï¥
        const newStartTime = Math.max(0, resizeState.originalStartTime + deltaTime);
        const maxStartTime = resizeState.originalStartTime + resizeState.originalDuration - 0.1;
        const clampedStartTime = Math.min(newStartTime, maxStartTime);
        const newDuration = resizeState.originalDuration - (clampedStartTime - resizeState.originalStartTime);

        updatedClip = {
          ...clip,
          startTime: clampedStartTime,
          duration: Math.max(0.1, newDuration),
          trimStart: Math.max(0, clip.trimStart + (clampedStartTime - resizeState.originalStartTime))
        };
      } else {
        // Âè≥Á´Ø„ÅÆ„É™„Çµ„Ç§„Ç∫ - Èï∑„Åï„ÅÆ„ÅøË™øÊï¥
        const newDuration = Math.max(0.1, resizeState.originalDuration + deltaTime);
        const maxDuration = (clip.trimEnd || clip.duration) - clip.trimStart;
        
        updatedClip = {
          ...clip,
          duration: Math.min(newDuration, maxDuration)
        };
      }

      console.log(`üîß Resizing ${resizeState.edge} edge of clip ${resizeState.clipId}: ${updatedClip.startTime.toFixed(2)}s, ${updatedClip.duration.toFixed(2)}s`);

      const updatedClips = timeline.clips.map(c =>
        c.id === resizeState.clipId ? updatedClip : c
      );

      onTimelineUpdate({
        ...timeline,
        clips: updatedClips
      });
    }
  }, [dragState, resizeState, timeline, pixelToTime, onTimelineUpdate]);

  const handleMouseUp = useCallback(() => {
    if (dragState.isDragging) {
      console.log(`‚úÖ Drag completed for clip: ${dragState.clipId}`);
      setDragState({
        isDragging: false,
        clipId: null,
        startX: 0,
        startTime: 0
      });
    }

    if (resizeState.isResizing) {
      console.log(`‚úÖ Resize completed for clip: ${resizeState.clipId}`);
      setResizeState({
        isResizing: false,
        clipId: null,
        edge: null,
        startX: 0,
        originalStartTime: 0,
        originalDuration: 0
      });
    }

    // „Éû„Ç¶„Çπ„Ç´„Éº„ÇΩ„É´„ÇíÊàª„Åô
    document.body.style.cursor = '';
  }, [dragState, resizeState]);

  // ========== „É™„Çµ„Ç§„Ç∫Âá¶ÁêÜ ==========
  const handleResizeMouseDown = useCallback((e: React.MouseEvent, clip: TimelineClip, edge: 'left' | 'right') => {
    e.preventDefault();
    e.stopPropagation();

    console.log(`üîß Starting resize ${edge} for clip: ${clip.id}`);

    setResizeState({
      isResizing: true,
      clipId: clip.id,
      edge,
      startX: e.clientX,
      originalStartTime: clip.startTime,
      originalDuration: clip.duration
    });

    // „Éû„Ç¶„Çπ„Ç´„Éº„ÇΩ„É´„ÇíÂ§âÊõ¥
    document.body.style.cursor = 'col-resize';
  }, []);

  // ========== „Éû„Ç¶„Çπ„Ç§„Éô„É≥„Éà„É™„Çπ„Éä„Éº ==========
  useEffect(() => {
    const handleGlobalMouseMove = (e: MouseEvent) => handleMouseMove(e);
    const handleGlobalMouseUp = () => handleMouseUp();

    if (dragState.isDragging || resizeState.isResizing) {
      document.addEventListener('mousemove', handleGlobalMouseMove);
      document.addEventListener('mouseup', handleGlobalMouseUp);
      
      // „Éâ„É©„ÉÉ„Ç∞‰∏≠„ÅØÈÅ∏Êäû„ÇíÁÑ°Âäπ„Å´„Åô„Çã
      document.body.style.userSelect = 'none';

      return () => {
        document.removeEventListener('mousemove', handleGlobalMouseMove);
        document.removeEventListener('mouseup', handleGlobalMouseUp);
        document.body.style.userSelect = '';
        document.body.style.cursor = '';
      };
    }
  }, [dragState.isDragging, resizeState.isResizing, handleMouseMove, handleMouseUp]);

  // ========== „ÇØ„É™„ÉÉ„ÉóÊìç‰ΩúÊ©üËÉΩ ==========
  const selectedClip = selectedClipId ? timeline.clips.find(clip => clip.id === selectedClipId) : null;
  const canSplit = selectedClip && 
    playheadPosition > selectedClip.startTime && 
    playheadPosition < selectedClip.startTime + selectedClip.duration;

  const handleClipSelect = useCallback((clip: TimelineClip) => {
    console.log(`üéØ Clip selected: ${clip.id}`);
    setSelectedClipId(clip.id);
    onClipSelect(clip);
  }, [onClipSelect]);

  const handleClipDelete = useCallback((clipId: string) => {
    console.log(`üóëÔ∏è Deleting clip: ${clipId}`);
    const updatedClips = timeline.clips.filter(clip => clip.id !== clipId);
    onTimelineUpdate({
      ...timeline,
      clips: updatedClips
    });
    
    if (selectedClipId === clipId) {
      setSelectedClipId(null);
    }
  }, [timeline, onTimelineUpdate, selectedClipId]);

  const splitClipAtPlayhead = useCallback(() => {
    if (!selectedClipId || !selectedClip) {
      console.warn('No clip selected for splitting');
      return;
    }

    const clipEndTime = selectedClip.startTime + selectedClip.duration;
    if (playheadPosition <= selectedClip.startTime || playheadPosition >= clipEndTime) {
      console.warn('Playhead is not within the selected clip');
      return;
    }

    const splitPosition = playheadPosition - selectedClip.startTime;
    const newClipId = `${selectedClip.id}_split_${Date.now()}`;
    
    const leftClip: TimelineClip = {
      ...selectedClip,
      duration: splitPosition,
      trimEnd: selectedClip.trimStart + splitPosition
    };
    
    const rightClip: TimelineClip = {
      ...selectedClip,
      id: newClipId,
      startTime: playheadPosition,
      duration: selectedClip.duration - splitPosition,
      trimStart: selectedClip.trimStart + splitPosition
    };

    const updatedClips = timeline.clips.map(clip => 
      clip.id === selectedClipId ? leftClip : clip
    ).concat(rightClip);
    
    onTimelineUpdate({
      ...timeline,
      clips: updatedClips
    });
    
    console.log(`‚úÇÔ∏è Clip split: ${selectedClip.id} ‚Üí ${leftClip.id} + ${rightClip.id}`);
  }, [selectedClipId, selectedClip, timeline, playheadPosition, onTimelineUpdate]);

  const copySelectedClip = useCallback(() => {
    if (!selectedClipId || !selectedClip) {
      console.warn('No clip selected for copying');
      return;
    }

    setCopiedClip(selectedClip);
    console.log(`üìã Clip copied: ${selectedClip.id}`);
  }, [selectedClipId, selectedClip]);

  const pasteClip = useCallback(() => {
    if (!copiedClip) {
      console.warn('No clip in clipboard');
      return;
    }

    const newClip: TimelineClip = {
      ...copiedClip,
      id: `${copiedClip.id}_copy_${Date.now()}`,
      startTime: playheadPosition,
      layer: 0
    };

    const updatedTimeline = {
      ...timeline,
      clips: [...timeline.clips, newClip]
    };
    
    onTimelineUpdate(updatedTimeline);
    setSelectedClipId(newClip.id);
    onClipSelect(newClip);
    console.log(`üìå Clip pasted: ${newClip.id} at ${playheadPosition}s`);
  }, [copiedClip, playheadPosition, timeline, onTimelineUpdate, onClipSelect]);

  // ========== „Éâ„É≠„ÉÉ„ÉóÂá¶ÁêÜ ==========
  const handleTrackDrop = useCallback((e: React.DragEvent, layer: number) => {
    e.preventDefault();
    const rect = e.currentTarget.getBoundingClientRect();
    const dropX = e.clientX - rect.left;
    const newStartTime = Math.max(0, pixelToTime(dropX));

    try {
      const transferData = e.dataTransfer.getData('application/json');
      
      if (!transferData || transferData.trim() === '') {
        console.warn('Empty drag data detected, ignoring drop');
        return;
      }
      
      let dragData;
      try {
        dragData = JSON.parse(transferData);
      } catch (parseError) {
        console.error('JSON parse failed:', parseError);
        return;
      }
      
      if (dragData.type === 'media') {
        const newClip: TimelineClip = {
          id: `clip-${Date.now()}`,
          mediaId: dragData.data.id,
          startTime: newStartTime,
          duration: dragData.data.duration || 5,
          trimStart: 0,
          trimEnd: dragData.data.duration || 5,
          layer,
          effects: dragData.data.type === 'image' ? [
            {
              id: `effect-${Date.now()}`,
              type: 'pan_zoom',
              parameters: { zoom: 1.1, panX: 0, panY: 0 },
              enabled: true
            }
          ] : undefined
        };
        
        console.log(`üì• Media dropped: ${dragData.data.id} ‚Üí clip ${newClip.id} at ${newStartTime.toFixed(2)}s`);
        
        const updatedTimeline = {
          ...timeline,
          clips: [...timeline.clips, newClip]
        };
        onTimelineUpdate(updatedTimeline);
      }
    } catch (error) {
      console.error('Failed to handle drop:', error);
    }
  }, [timeline, onTimelineUpdate, pixelToTime]);

  // ========== „Ç≠„Éº„Éú„Éº„Éâ„Ç∑„Éß„Éº„Éà„Ç´„ÉÉ„Éà ==========
  const handleKeyDown = useCallback((e: KeyboardEvent) => {
    const activeElement = document.activeElement;
    if (activeElement && (
      activeElement.tagName === 'INPUT' ||
      activeElement.tagName === 'TEXTAREA' ||
      activeElement.getAttribute('contenteditable') === 'true'
    )) {
      return;
    }

    if ((e.ctrlKey || e.metaKey) && e.key === 'c') {
      e.preventDefault();
      copySelectedClip();
    } else if ((e.ctrlKey || e.metaKey) && e.key === 'v') {
      e.preventDefault();
      pasteClip();
    } else if (e.key === 's' || e.key === 'S') {
      if (!(e.ctrlKey || e.metaKey)) {
        e.preventDefault();
        splitClipAtPlayhead();
      }
    } else if (e.key === 'Delete' || e.key === 'Backspace') {
      if (selectedClipId) {
        e.preventDefault();
        handleClipDelete(selectedClipId);
      }
    }
  }, [copySelectedClip, pasteClip, splitClipAtPlayhead, selectedClipId, handleClipDelete]);

  useEffect(() => {
    document.addEventListener('keydown', handleKeyDown);
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [handleKeyDown]);

  // ========== ÊôÇÈñì„Éû„Éº„Ç´„ÉºÁîüÊàê ==========
  const generateTimeMarkers = useCallback(() => {
    const markers = [];
    const maxTime = Math.max(timeline.duration, 60);
    const interval = zoom < 0.5 ? 10 : zoom < 1 ? 5 : 1;
    
    for (let i = 0; i <= maxTime; i += interval) {
      markers.push(i);
    }
    return markers;
  }, [timeline.duration, zoom]);

  const formatTime = useCallback((seconds: number) => {
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  }, []);

  return (
    <div className="h-full flex flex-col bg-dark-900">
      {/* Timeline Header */}
      <div className="bg-dark-800 border-b border-dark-700 p-4 flex items-center justify-between">
        <div className="flex items-center space-x-4">
          <div className="flex items-center space-x-2">
            <h3 className="text-lg font-semibold text-white">Timeline (‰øÆÊ≠£Áâà)</h3>
            {selectedClip && (
              <div className="text-sm text-purple-400 bg-purple-500/20 px-2 py-1 rounded">
                {selectedClip.id.slice(-8)} selected
              </div>
            )}
            {dragState.isDragging && (
              <div className="text-sm text-yellow-400 bg-yellow-500/20 px-2 py-1 rounded flex items-center space-x-1">
                <Zap className="w-3 h-3" />
                <span>Dragging...</span>
              </div>
            )}
            {resizeState.isResizing && (
              <div className="text-sm text-blue-400 bg-blue-500/20 px-2 py-1 rounded flex items-center space-x-1">
                <ArrowRightLeft className="w-3 h-3" />
                <span>Resizing {resizeState.edge}...</span>
              </div>
            )}
          </div>
          
          <div className="flex items-center space-x-2">
            <button
              className="p-2 hover:bg-dark-600 rounded-lg transition-colors"
              onClick={() => onTimelineUpdate({ ...timeline, zoom: Math.max(0.25, zoom - 0.25) })}
              title="Zoom out"
            >
              <ZoomOut className="w-4 h-4 text-gray-400" />
            </button>
            <span className="text-sm text-gray-400 min-w-[60px] text-center">
              {Math.round(zoom * 100)}%
            </span>
            <button
              className="p-2 hover:bg-dark-600 rounded-lg transition-colors"
              onClick={() => onTimelineUpdate({ ...timeline, zoom: Math.min(4, zoom + 0.25) })}
              title="Zoom in"
            >
              <ZoomIn className="w-4 h-4 text-gray-400" />
            </button>
          </div>
          
          <div className="hidden lg:flex items-center space-x-3 text-xs text-gray-500">
            <span>PPS: {pixelsPerSecond.toFixed(0)}</span>
            <span>Width: {timeToPixel(timeline.duration).toFixed(0)}px</span>
          </div>
        </div>
        
        <div className="flex items-center space-x-2">
          <button 
            className={`flex items-center space-x-1 px-3 py-2 rounded-lg text-sm font-medium transition-all ${
              copiedClip 
                ? 'bg-blue-500 hover:bg-blue-600 text-white' 
                : 'bg-dark-700 hover:bg-dark-600 text-gray-300'
            }`}
            onClick={copySelectedClip}
            disabled={!selectedClipId}
            title="Copy clip (Ctrl+C)"
          >
            <Copy className="w-4 h-4" />
            <span>Copy</span>
            {copiedClip && <span className="ml-1 text-xs bg-white/20 px-1 rounded">1</span>}
          </button>
          
          <button 
            className={`flex items-center space-x-1 px-3 py-2 rounded-lg text-sm font-medium transition-all ${
              canSplit 
                ? 'bg-green-500 hover:bg-green-600 text-white' 
                : 'bg-dark-700 hover:bg-dark-600 text-gray-400 cursor-not-allowed'
            }`}
            onClick={splitClipAtPlayhead}
            disabled={!canSplit}
            title={canSplit ? "Split clip at playhead (S)" : "Select a clip and position playhead to split"}
          >
            <Scissors className="w-4 h-4" />
            <span>Split</span>
          </button>
          
          <button 
            className={`flex items-center space-x-1 px-3 py-2 rounded-lg text-sm font-medium transition-all ${
              copiedClip 
                ? 'bg-purple-500 hover:bg-purple-600 text-white' 
                : 'bg-dark-700 hover:bg-dark-600 text-gray-400 cursor-not-allowed'
            }`}
            onClick={pasteClip}
            disabled={!copiedClip}
            title="Paste clip (Ctrl+V)"
          >
            <Plus className="w-4 h-4" />
            <span>Paste</span>
          </button>
        </div>
      </div>

      {/* Timeline Ruler */}
      <div className="bg-dark-850 border-b border-dark-700 h-8 relative overflow-hidden">
        <div 
          ref={timelineRef}
          className="h-full relative"
          style={{ width: timeToPixel(Math.max(timeline.duration, 60)) }}
        >
          {generateTimeMarkers().map(time => (
            <div
              key={time}
              className="absolute top-0 h-full flex items-center text-xs text-gray-400"
              style={{ left: timeToPixel(time) }}
            >
              <div className="w-px h-3 bg-gray-600 mr-2" />
              {formatTime(time)}
            </div>
          ))}
          
          {/* Playhead */}
          <motion.div
            ref={playheadRef}
            className="absolute top-0 w-0.5 h-full bg-red-500 z-10"
            style={{ left: timeToPixel(playheadPosition) }}
            animate={{ left: timeToPixel(playheadPosition) }}
            transition={{ type: "tween", duration: 0.1 }}
          >
            <div className="w-3 h-3 bg-red-500 rounded-full -ml-1.5 -mt-1" />
          </motion.div>
        </div>
      </div>

      {/* Timeline Tracks */}
      <div className="flex-1 overflow-auto scrollbar-thin">
        <div className="relative">
          {/* Video Tracks */}
          {Array.from({ length: 3 }, (_, layerIndex) => (
            <div key={`video-${layerIndex}`} className="flex">
              <div className="w-24 bg-dark-800 border-r border-dark-700 flex items-center justify-center text-sm text-gray-400 font-medium"
                   style={{ height: trackHeight }}>
                Video {layerIndex + 1}
              </div>
              
              <div
                className="flex-1 relative border-b border-dark-700"
                style={{ 
                  height: trackHeight,
                  width: timeToPixel(Math.max(timeline.duration, 60))
                }}
                onDrop={(e) => handleTrackDrop(e, layerIndex)}
                onDragOver={(e) => e.preventDefault()}
              >
                <div className="absolute inset-0 bg-dark-850 hover:bg-dark-800 transition-colors" />
                
                {/* Clips on this layer */}
                <AnimatePresence>
                  {timeline.clips
                    .filter(clip => clip.layer === layerIndex)
                    .map(clip => (
                      <motion.div
                        key={clip.id}
                        initial={{ opacity: 0, scale: 0.9 }}
                        animate={{ opacity: 1, scale: 1 }}
                        exit={{ opacity: 0, scale: 0.9 }}
                        className={`absolute timeline-clip group border-2 overflow-hidden cursor-grab active:cursor-grabbing ${
                          selectedClipId === clip.id 
                            ? 'ring-2 ring-yellow-400 border-yellow-300 bg-blue-600/80' 
                            : 'border-gray-600 bg-blue-500/60 hover:bg-blue-500/80'
                        } ${dragState.isDragging && dragState.clipId === clip.id ? 'z-50 shadow-2xl' : ''}`}
                        style={{
                          left: timeToPixel(clip.startTime),
                          width: timeToPixel(clip.duration),
                          height: trackHeight - 8,
                          top: 4,
                          borderRadius: '6px'
                        }}
                        onMouseDown={(e) => handleClipMouseDown(e, clip)}
                        onClick={(e) => {
                          e.stopPropagation();
                          handleClipSelect(clip);
                        }}
                        whileHover={{ scale: 1.02 }}
                        whileTap={{ scale: 0.98 }}
                      >
                        {/* Â∑¶Á´Ø„É™„Çµ„Ç§„Ç∫„Éè„É≥„Éâ„É´ */}
                        <div
                          className="resize-handle absolute left-0 top-0 w-2 h-full bg-white/30 hover:bg-white/50 cursor-col-resize opacity-0 group-hover:opacity-100 transition-opacity z-10"
                          onMouseDown={(e) => handleResizeMouseDown(e, clip, 'left')}
                          title="Resize clip start"
                        />
                        
                        {/* „ÇØ„É™„ÉÉ„Éó„Ç≥„É≥„ÉÜ„É≥„ÉÑ */}
                        <div className="flex items-center justify-between h-full px-3 py-1 relative">
                          <div className="flex flex-col justify-center min-w-0 flex-1">
                            <span className="text-xs font-semibold text-white truncate">
                              Clip {clip.id.slice(-4)}
                            </span>
                            {selectedClipId === clip.id && (
                              <div className="text-xs text-white/80 mt-0.5">
                                {formatTime(clip.startTime)} - {formatTime(clip.startTime + clip.duration)}
                                <span className="ml-2 text-white/60">({formatTime(clip.duration)})</span>
                              </div>
                            )}
                          </div>
                          
                          <button
                            className="p-1 hover:bg-red-500 rounded opacity-0 group-hover:opacity-100 transition-all z-10"
                            onClick={(e) => {
                              e.stopPropagation();
                              handleClipDelete(clip.id);
                            }}
                            title="Delete clip (Delete key)"
                          >
                            <Trash2 className="w-3 h-3 text-white" />
                          </button>
                        </div>
                        
                        {/* Âè≥Á´Ø„É™„Çµ„Ç§„Ç∫„Éè„É≥„Éâ„É´ */}
                        <div
                          className="resize-handle absolute right-0 top-0 w-2 h-full bg-white/30 hover:bg-white/50 cursor-col-resize opacity-0 group-hover:opacity-100 transition-opacity z-10"
                          onMouseDown={(e) => handleResizeMouseDown(e, clip, 'right')}
                          title="Resize clip end"
                        />
                        
                        {/* ÈÅ∏Êäû/„Éâ„É©„ÉÉ„Ç∞„Ç§„É≥„Ç∏„Ç±„Éº„Çø„Éº */}
                        {selectedClipId === clip.id && (
                          <div className="absolute inset-0 border-2 border-yellow-400 rounded-md pointer-events-none" />
                        )}
                        
                        {dragState.isDragging && dragState.clipId === clip.id && (
                          <div className="absolute inset-0 border-2 border-yellow-400 rounded-md pointer-events-none animate-pulse bg-yellow-400/20" />
                        )}
                      </motion.div>
                    ))}
                </AnimatePresence>
              </div>
            </div>
          ))}

          {/* Audio Tracks */}
          {timeline.audioTracks.map((audioTrack, index) => (
            <div key={audioTrack.id} className="flex">
              <div className="w-24 bg-dark-800 border-r border-dark-700 flex items-center justify-center text-sm text-gray-400 font-medium"
                   style={{ height: audioTrackHeight }}>
                <Volume2 className="w-4 h-4 mr-1" />
                Audio {index + 1}
              </div>
              
              <div
                className="flex-1 relative border-b border-dark-700"
                style={{ 
                  height: audioTrackHeight,
                  width: timeToPixel(Math.max(timeline.duration, 60))
                }}
              >
                <div className="absolute inset-0 bg-dark-850" />
                
                <div
                  className="absolute"
                  style={{
                    left: timeToPixel(audioTrack.startTime),
                    width: timeToPixel(audioTrack.duration),
                    height: audioTrackHeight - 8,
                    top: 4
                  }}
                >
                  {audioTrack.url ? (
                    <WaveformDisplay
                      audioTrack={audioTrack}
                      width={timeToPixel(audioTrack.duration)}
                      height={audioTrackHeight - 8}
                      startTime={audioTrack.startTime}
                      duration={audioTrack.duration}
                      zoom={zoom}
                      color="#06b6d4"
                      showBeats={true}
                      className="rounded border border-cyan-500/30 bg-cyan-500/10"
                      onWaveformClick={(time) => {
                        console.log('Waveform clicked at time:', time);
                      }}
                    />
                  ) : (
                    <div className="flex items-center h-full px-2 bg-cyan-500/10 border border-cyan-500/30 rounded">
                      <Activity className="w-3 h-3 mr-1 text-cyan-400" />
                      <span className="text-xs truncate text-cyan-300">
                        {audioTrack.name || 'Audio Track'}
                      </span>
                      {audioTrack.bpm && (
                        <span className="ml-auto text-xs text-cyan-400">
                          {audioTrack.bpm} BPM
                        </span>
                      )}
                    </div>
                  )}
                </div>

                {!audioTrack.url && audioTrack.beats && audioTrack.beats.map((beatTime, beatIndex) => (
                  <div
                    key={beatIndex}
                    className="absolute w-px h-full bg-yellow-400 opacity-30"
                    style={{ left: timeToPixel(beatTime) }}
                  />
                ))}
              </div>
            </div>
          ))}

          {/* Add Track Button */}
          <div className="flex">
            <div className="w-24 bg-dark-800 border-r border-dark-700" />
            <button className="flex-1 h-12 border-b border-dark-700 bg-dark-850 hover:bg-dark-800 transition-colors flex items-center justify-center text-gray-400 text-sm">
              <Plus className="w-4 h-4 mr-2" />
              Add Track
            </button>
          </div>
        </div>
      </div>

      {/* Debug Info */}
      {process.env.NODE_ENV === 'development' && (
        <div className="bg-dark-800 border-t border-dark-700 px-4 py-2 text-xs text-gray-500">
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-4">
              <span>Clips: {timeline.clips.length}</span>
              <span>Selected: {selectedClipId || 'none'}</span>
              <span>Dragging: {dragState.isDragging ? dragState.clipId : 'false'}</span>
              <span>Resizing: {resizeState.isResizing ? `${resizeState.clipId} (${resizeState.edge})` : 'false'}</span>
            </div>
            <div className="flex items-center space-x-4">
              <span>Zoom: {Math.round(zoom * 100)}%</span>
              <span>PPS: {pixelsPerSecond.toFixed(0)}</span>
              <span>Playhead: {playheadPosition.toFixed(2)}s</span>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default Timeline;