import React, { useState, useRef, useEffect, useCallback, useMemo } from 'react';\nimport { motion, AnimatePresence } from 'framer-motion';\nimport { \n  Grid3X3, \n  Magnet, \n  Scissors, \n  Settings, \n  Info, \n  ChevronDown,\n  Ruler,\n  Play,\n  Target\n} from 'lucide-react';\n\nimport { \n  BeatTimelineProps, \n  TimelineClip, \n  BeatGrid, \n  BPMAnalysis, \n  Timeline,\n  EditRecipe\n} from '../../types';\n\n/**\n * ビートスナップ機能付き拡張タイムライン\n * 初心者にもわかりやすいビート同期機能を提供\n */\nconst BeatTimeline: React.FC<BeatTimelineProps> = ({\n  timeline,\n  playheadPosition,\n  zoom,\n  onClipSelect,\n  onTimelineUpdate,\n  onPlayheadChange,\n  bpmAnalysis,\n  beatGrid,\n  onBeatGridChange,\n  showBeatMarkers = true,\n  showBarMarkers = true\n}) => {\n  const timelineRef = useRef<HTMLDivElement>(null);\n  const [isDragging, setIsDragging] = useState(false);\n  const [draggedClip, setDraggedClip] = useState<TimelineClip | null>(null);\n  const [snapPreview, setSnapPreview] = useState<number | null>(null);\n  const [showGridSettings, setShowGridSettings] = useState(false);\n  const [selectedClipId, setSelectedClipId] = useState<string | null>(null);\n\n  // タイムライン描画の基本設定\n  const pixelsPerSecond = 50 * zoom;\n  const timelineWidth = timeline.duration * pixelsPerSecond;\n  const trackHeight = 80;\n  const headerHeight = 60;\n\n  // ビートマーカーの計算\n  const beatMarkers = useMemo(() => {\n    if (!bpmAnalysis || !showBeatMarkers) return [];\n    \n    return bpmAnalysis.beatTimes.map(time => ({\n      time,\n      x: time * pixelsPerSecond,\n      type: 'beat' as const\n    }));\n  }, [bpmAnalysis, pixelsPerSecond, showBeatMarkers]);\n\n  // 小節マーカーの計算\n  const barMarkers = useMemo(() => {\n    if (!bpmAnalysis || !showBarMarkers) return [];\n    \n    return bpmAnalysis.bars.map(time => ({\n      time,\n      x: time * pixelsPerSecond,\n      type: 'bar' as const\n    }));\n  }, [bpmAnalysis, pixelsPerSecond, showBarMarkers]);\n\n  // スナップポイントの計算\n  const snapPoints = useMemo(() => {\n    const points: number[] = [];\n    \n    if (beatGrid.snapToBeat && bpmAnalysis) {\n      points.push(...bpmAnalysis.beatTimes);\n    }\n    \n    if (beatGrid.snapToBar && bpmAnalysis) {\n      points.push(...bpmAnalysis.bars);\n    }\n    \n    // サブディビジョンの追加\n    if (beatGrid.subdivisions > 1 && bpmAnalysis) {\n      const subdivisionInterval = (60 / bpmAnalysis.bpm) / beatGrid.subdivisions;\n      for (let time = 0; time <= timeline.duration; time += subdivisionInterval) {\n        points.push(time);\n      }\n    }\n    \n    return points.sort((a, b) => a - b);\n  }, [beatGrid, bpmAnalysis, timeline.duration]);\n\n  // 最も近いスナップポイントを見つける\n  const findNearestSnapPoint = useCallback((time: number): number => {\n    if (!beatGrid.enabled) return time;\n    \n    const snapDistance = 0.1; // 0.1秒以内でスナップ\n    let nearestPoint = time;\n    let minDistance = snapDistance;\n    \n    snapPoints.forEach(point => {\n      const distance = Math.abs(time - point);\n      if (distance < minDistance) {\n        minDistance = distance;\n        nearestPoint = point;\n      }\n    });\n    \n    return nearestPoint;\n  }, [beatGrid.enabled, snapPoints]);\n\n  // クリップのドラッグ処理\n  const handleClipMouseDown = (e: React.MouseEvent, clip: TimelineClip) => {\n    e.preventDefault();\n    setIsDragging(true);\n    setDraggedClip(clip);\n    setSelectedClipId(clip.id);\n    onClipSelect(clip);\n  };\n\n  // マウス移動時の処理\n  const handleMouseMove = useCallback((e: MouseEvent) => {\n    if (!isDragging || !draggedClip || !timelineRef.current) return;\n\n    const rect = timelineRef.current.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const time = x / pixelsPerSecond;\n    \n    // スナップ処理\n    const snappedTime = findNearestSnapPoint(time);\n    setSnapPreview(snappedTime);\n\n    // クリップ位置の更新\n    const updatedClip = {\n      ...draggedClip,\n      startTime: Math.max(0, snappedTime)\n    };\n\n    const updatedTimeline = {\n      ...timeline,\n      clips: timeline.clips.map(clip => \n        clip.id === draggedClip.id ? updatedClip : clip\n      )\n    };\n\n    onTimelineUpdate(updatedTimeline);\n  }, [isDragging, draggedClip, pixelsPerSecond, findNearestSnapPoint, timeline, onTimelineUpdate]);\n\n  // マウスリリース時の処理\n  const handleMouseUp = useCallback(() => {\n    setIsDragging(false);\n    setDraggedClip(null);\n    setSnapPreview(null);\n  }, []);\n\n  // マウスイベントの登録\n  useEffect(() => {\n    if (isDragging) {\n      document.addEventListener('mousemove', handleMouseMove);\n      document.addEventListener('mouseup', handleMouseUp);\n      \n      return () => {\n        document.removeEventListener('mousemove', handleMouseMove);\n        document.removeEventListener('mouseup', handleMouseUp);\n      };\n    }\n  }, [isDragging, handleMouseMove, handleMouseUp]);\n\n  // プレイヘッドクリック処理\n  const handleTimelineClick = (e: React.MouseEvent) => {\n    if (!timelineRef.current) return;\n    \n    const rect = timelineRef.current.getBoundingClientRect();\n    const x = e.clientX - rect.left;\n    const time = x / pixelsPerSecond;\n    \n    // スナップ処理\n    const snappedTime = findNearestSnapPoint(time);\n    onPlayheadChange?.(Math.max(0, Math.min(snappedTime, timeline.duration)));\n  };\n\n  // ビートグリッド設定の更新\n  const updateBeatGrid = (updates: Partial<BeatGrid>) => {\n    onBeatGridChange({ ...beatGrid, ...updates });\n  };\n\n  return (\n    <div className=\"bg-dark-900 border-t border-dark-700\">\n      {/* タイムラインヘッダー */}\n      <div className=\"bg-dark-800 border-b border-dark-700 px-4 py-3\">\n        <div className=\"flex items-center justify-between\">\n          {/* 左側：BPM情報 */}\n          <div className=\"flex items-center space-x-4\">\n            {bpmAnalysis && (\n              <div className=\"flex items-center space-x-2 bg-purple-500/20 px-3 py-1.5 rounded-lg\">\n                <Play className=\"w-3 h-3 text-purple-400\" />\n                <span className=\"text-sm font-medium text-white\">{bpmAnalysis.bpm} BPM</span>\n                <span className=\"text-xs text-gray-400\">\n                  {bpmAnalysis.timeSignature.numerator}/{bpmAnalysis.timeSignature.denominator}\n                </span>\n              </div>\n            )}\n            \n            <div className=\"text-sm text-gray-400\">\n              {timeline.clips.length}個のクリップ • {Math.floor(timeline.duration / 60)}:{(timeline.duration % 60).toFixed(0).padStart(2, '0')}\n            </div>\n          </div>\n\n          {/* 右側：グリッド設定 */}\n          <div className=\"flex items-center space-x-2\">\n            {/* ビートスナップトグル */}\n            <button\n              onClick={() => updateBeatGrid({ enabled: !beatGrid.enabled })}\n              className={`flex items-center space-x-1 px-3 py-1.5 rounded-lg text-sm transition-all ${\n                beatGrid.enabled\n                  ? 'bg-purple-500 text-white'\n                  : 'bg-dark-700 text-gray-400 hover:text-white'\n              }`}\n            >\n              <Magnet className=\"w-3 h-3\" />\n              <span>スナップ</span>\n            </button>\n\n            {/* グリッド設定ボタン */}\n            <button\n              onClick={() => setShowGridSettings(!showGridSettings)}\n              className=\"flex items-center space-x-1 bg-dark-700 hover:bg-dark-600 text-gray-400 hover:text-white px-3 py-1.5 rounded-lg text-sm transition-all\"\n            >\n              <Settings className=\"w-3 h-3\" />\n              <ChevronDown className={`w-3 h-3 transition-transform ${\n                showGridSettings ? 'rotate-180' : ''\n              }`} />\n            </button>\n          </div>\n        </div>\n\n        {/* グリッド設定パネル */}\n        <AnimatePresence>\n          {showGridSettings && (\n            <motion.div\n              initial={{ opacity: 0, height: 0 }}\n              animate={{ opacity: 1, height: 'auto' }}\n              exit={{ opacity: 0, height: 0 }}\n              className=\"mt-3 pt-3 border-t border-dark-700\"\n            >\n              <div className=\"grid grid-cols-2 md:grid-cols-4 gap-4\">\n                {/* ビートスナップ */}\n                <label className=\"flex items-center space-x-2\">\n                  <input\n                    type=\"checkbox\"\n                    checked={beatGrid.snapToBeat}\n                    onChange={(e) => updateBeatGrid({ snapToBeat: e.target.checked })}\n                    className=\"w-4 h-4 text-purple-500 bg-dark-700 border-dark-600 rounded\"\n                  />\n                  <span className=\"text-sm text-gray-300\">ビートにスナップ</span>\n                </label>\n\n                {/* 小節スナップ */}\n                <label className=\"flex items-center space-x-2\">\n                  <input\n                    type=\"checkbox\"\n                    checked={beatGrid.snapToBar}\n                    onChange={(e) => updateBeatGrid({ snapToBar: e.target.checked })}\n                    className=\"w-4 h-4 text-purple-500 bg-dark-700 border-dark-600 rounded\"\n                  />\n                  <span className=\"text-sm text-gray-300\">小節にスナップ</span>\n                </label>\n\n                {/* サブディビジョン */}\n                <div className=\"flex items-center space-x-2\">\n                  <span className=\"text-sm text-gray-400\">分割:</span>\n                  <select\n                    value={beatGrid.subdivisions}\n                    onChange={(e) => updateBeatGrid({ subdivisions: Number(e.target.value) as 1 | 2 | 4 | 8 | 16 })}\n                    className=\"bg-dark-700 border border-dark-600 rounded px-2 py-1 text-sm text-white\"\n                  >\n                    <option value={1}>1</option>\n                    <option value={2}>1/2</option>\n                    <option value={4}>1/4</option>\n                    <option value={8}>1/8</option>\n                    <option value={16}>1/16</option>\n                  </select>\n                </div>\n\n                {/* クオンタイズ強度 */}\n                <div className=\"flex items-center space-x-2\">\n                  <span className=\"text-sm text-gray-400\">強度:</span>\n                  <input\n                    type=\"range\"\n                    min={0}\n                    max={1}\n                    step={0.1}\n                    value={beatGrid.quantizeStrength}\n                    onChange={(e) => updateBeatGrid({ quantizeStrength: Number(e.target.value) })}\n                    className=\"flex-1\"\n                  />\n                  <span className=\"text-xs text-gray-400 w-8\">{Math.round(beatGrid.quantizeStrength * 100)}%</span>\n                </div>\n              </div>\n            </motion.div>\n          )}\n        </AnimatePresence>\n      </div>\n\n      {/* タイムライン本体 */}\n      <div className=\"relative overflow-x-auto overflow-y-hidden\">\n        <div \n          ref={timelineRef}\n          className=\"relative bg-dark-900 cursor-pointer min-h-[200px]\"\n          style={{ width: Math.max(timelineWidth, 800) }}\n          onClick={handleTimelineClick}\n        >\n          {/* ビートマーカー */}\n          {beatMarkers.map((marker, index) => (\n            <div\n              key={`beat-${index}`}\n              className=\"absolute top-0 bottom-0 w-px bg-purple-400/30 pointer-events-none\"\n              style={{ left: marker.x }}\n            >\n              <div className=\"absolute -top-2 left-1/2 transform -translate-x-1/2\">\n                <div className=\"w-1 h-1 bg-purple-400 rounded-full\" />\n              </div>\n            </div>\n          ))}\n\n          {/* 小節マーカー */}\n          {barMarkers.map((marker, index) => (\n            <div\n              key={`bar-${index}`}\n              className=\"absolute top-0 bottom-0 w-px bg-purple-500/60 pointer-events-none\"\n              style={{ left: marker.x }}\n            >\n              <div className=\"absolute -top-3 left-1/2 transform -translate-x-1/2\">\n                <div className=\"w-2 h-2 bg-purple-500 rounded-full\" />\n              </div>\n              <div className=\"absolute top-2 left-2 text-xs text-purple-400 font-mono\">\n                {Math.floor(marker.time / (60 / (bpmAnalysis?.bpm || 120) * 4)) + 1}\n              </div>\n            </div>\n          ))}\n\n          {/* スナップ予告線 */}\n          {snapPreview !== null && (\n            <div\n              className=\"absolute top-0 bottom-0 w-px bg-yellow-400 pointer-events-none z-10\"\n              style={{ left: snapPreview * pixelsPerSecond }}\n            >\n              <div className=\"absolute -top-2 left-1/2 transform -translate-x-1/2\">\n                <Target className=\"w-3 h-3 text-yellow-400\" />\n              </div>\n            </div>\n          )}\n\n          {/* クリップ表示 */}\n          {timeline.clips.map((clip, layerIndex) => {\n            const clipX = clip.startTime * pixelsPerSecond;\n            const clipWidth = clip.duration * pixelsPerSecond;\n            const clipY = headerHeight + layerIndex * (trackHeight + 10);\n\n            return (\n              <motion.div\n                key={clip.id}\n                className={`absolute bg-gradient-to-r from-blue-500 to-blue-600 rounded cursor-move border-2 ${\n                  selectedClipId === clip.id\n                    ? 'border-purple-400 shadow-lg shadow-purple-400/20'\n                    : 'border-blue-400/30 hover:border-blue-400'\n                } transition-all`}\n                style={{\n                  left: clipX,\n                  top: clipY,\n                  width: Math.max(clipWidth, 50),\n                  height: trackHeight\n                }}\n                onMouseDown={(e) => handleClipMouseDown(e, clip)}\n                whileHover={{ scale: 1.02 }}\n                whileTap={{ scale: 0.98 }}\n              >\n                <div className=\"p-2 h-full flex flex-col justify-between text-white text-xs\">\n                  <div className=\"font-medium truncate\">\n                    {timeline.clips.findIndex(c => c.id === clip.id) + 1}. クリップ\n                  </div>\n                  <div className=\"text-blue-200 text-xs\">\n                    {clip.duration.toFixed(1)}s\n                  </div>\n                </div>\n\n                {/* クリップのビート同期インジケーター */}\n                {beatGrid.enabled && bpmAnalysis && (\n                  <div className=\"absolute top-1 right-1\">\n                    <Magnet className=\"w-3 h-3 text-purple-300\" />\n                  </div>\n                )}\n              </motion.div>\n            );\n          })}\n\n          {/* プレイヘッド */}\n          <div\n            className=\"absolute top-0 bottom-0 w-0.5 bg-red-500 pointer-events-none z-20\"\n            style={{ left: playheadPosition * pixelsPerSecond }}\n          >\n            <div className=\"absolute -top-2 left-1/2 transform -translate-x-1/2\">\n              <div className=\"w-3 h-3 bg-red-500 rotate-45\" />\n            </div>\n          </div>\n\n          {/* 時間軸 */}\n          <div className=\"absolute top-0 left-0 right-0 h-8 bg-dark-800 border-b border-dark-700\">\n            {Array.from({ length: Math.ceil(timeline.duration) + 1 }, (_, i) => (\n              <div\n                key={i}\n                className=\"absolute top-0 h-full flex items-center\"\n                style={{ left: i * pixelsPerSecond }}\n              >\n                <div className=\"w-px h-2 bg-gray-600\" />\n                <span className=\"ml-1 text-xs text-gray-400 font-mono\">\n                  {Math.floor(i / 60)}:{(i % 60).toString().padStart(2, '0')}\n                </span>\n              </div>\n            ))}\n          </div>\n        </div>\n      </div>\n\n      {/* ヘルプテキスト */}\n      <div className=\"bg-dark-800 border-t border-dark-700 px-4 py-2\">\n        <div className=\"flex items-center space-x-2 text-xs text-gray-400\">\n          <Info className=\"w-3 h-3\" />\n          <span>\n            {beatGrid.enabled \n              ? 'ビートスナップが有効です。クリップを拍に合わせて自動調整します。'\n              : 'スナップボタンを押すとビートに合わせて自動配置できます。'\n            }\n          </span>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default BeatTimeline;"