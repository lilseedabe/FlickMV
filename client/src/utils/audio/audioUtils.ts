import { BPMAnalysis, AudioAnalysis, FrequencyBand } from '../../types';\n\n/**\n * 音声解析の補助ユーティリティ関数集\n * 初心者にも理解しやすいよう詳細にコメント\n */\n\n/**\n * BPMから拍間隔を計算\n * @param bpm - Beats Per Minute\n * @returns 拍間隔（秒）\n */\nexport function calculateBeatInterval(bpm: number): number {\n  return 60 / bpm;\n}\n\n/**\n * BPMから小節間隔を計算（4/4拍子を想定）\n * @param bpm - Beats Per Minute\n * @param timeSignature - 拍子記号の分子（デフォルト: 4）\n * @returns 小節間隔（秒）\n */\nexport function calculateBarInterval(bpm: number, timeSignature: number = 4): number {\n  return (60 / bpm) * timeSignature;\n}\n\n/**\n * 指定した時間に最も近いビートタイムを取得\n * @param time - 基準時間（秒）\n * @param beatTimes - ビートタイムの配列\n * @returns 最も近いビートタイム\n */\nexport function getClosestBeatTime(time: number, beatTimes: number[]): number {\n  if (beatTimes.length === 0) return time;\n  \n  return beatTimes.reduce((closest, current) => {\n    return Math.abs(current - time) < Math.abs(closest - time) ? current : closest;\n  });\n}\n\n/**\n * 指定した時間に最も近い小節開始時間を取得\n * @param time - 基準時間（秒）\n * @param barTimes - 小節開始時間の配列\n * @returns 最も近い小節開始時間\n */\nexport function getClosestBarTime(time: number, barTimes: number[]): number {\n  if (barTimes.length === 0) return time;\n  \n  return barTimes.reduce((closest, current) => {\n    return Math.abs(current - time) < Math.abs(closest - time) ? current : closest;\n  });\n}\n\n/**\n * BPMの信頼度に基づく推奨事項を生成\n * @param analysis - BPM解析結果\n * @returns 推奨事項の配列\n */\nexport function generateBPMRecommendations(analysis: BPMAnalysis): string[] {\n  const recommendations: string[] = [];\n  \n  if (analysis.confidence >= 0.9) {\n    recommendations.push('BPM検出の精度が非常に高いです。ビート同期機能を積極的に活用できます。');\n  } else if (analysis.confidence >= 0.7) {\n    recommendations.push('BPM検出の精度は良好です。ビート同期機能が有効に働きます。');\n  } else if (analysis.confidence >= 0.5) {\n    recommendations.push('BPM検出の精度は中程度です。手動でビートマーカーを調整することをお勧めします。');\n  } else {\n    recommendations.push('BPM検出の精度が低いです。手動でのビート設定をお勧めします。');\n  }\n  \n  // BPMに基づく推奨事項\n  if (analysis.bpm < 80) {\n    recommendations.push('スローテンポなので、ゆったりとしたトランジションやエフェクトが効果的です。');\n  } else if (analysis.bpm > 140) {\n    recommendations.push('ハイテンポなので、クイックカットや激しいエフェクトが映えます。');\n  }\n  \n  // ビート数に基づく推奨事項\n  if (analysis.beatTimes.length > 100) {\n    recommendations.push('十分なビート数が検出されました。細かなビート同期編集が可能です。');\n  }\n  \n  return recommendations;\n}\n\n/**\n * 周波数帯域の解析結果から推奨エフェクトを提案\n * @param bands - 周波数帯域の配列\n * @returns 推奨エフェクトの配列\n */\nexport function suggestEffectsFromFrequency(bands: FrequencyBand[]): string[] {\n  const suggestions: string[] = [];\n  \n  bands.forEach(band => {\n    if (band.triggered) {\n      switch (band.name.toLowerCase()) {\n        case 'bass':\n        case 'sub_bass':\n        case 'kick':\n          suggestions.push('低音域でトリガー: 画面シェイクやフラッシュエフェクトが効果的');\n          break;\n        case 'highs':\n        case 'brilliance':\n        case 'presence':\n          suggestions.push('高音域でトリガー: パーティクルやグロウエフェクトがお勧め');\n          break;\n        case 'vocals':\n        case 'mids':\n          suggestions.push('中音域でトリガー: カラーグレーディングや軽いズームが適しています');\n          break;\n        case 'snare':\n          suggestions.push('スネア音でトリガー: 瞬間的なカットやフラッシュがリズム感を演出');\n          break;\n      }\n    }\n  });\n  \n  return [...new Set(suggestions)]; // 重複を除去\n}\n\n/**\n * 音楽ジャンルをBPMから推測\n * @param bpm - Beats Per Minute\n * @returns 推測されるジャンル\n */\nexport function guessGenreFromBPM(bpm: number): string {\n  if (bpm < 70) return 'Ambient/Downtempo';\n  if (bpm < 90) return 'Hip-Hop/Trap';\n  if (bpm < 100) return 'Lo-fi/Chill';\n  if (bpm < 120) return 'Pop/Rock';\n  if (bpm < 130) return 'House/Dance';\n  if (bpm < 140) return 'Techno/Trance';\n  if (bpm < 160) return 'Drum & Bass';\n  if (bpm < 180) return 'Hardcore/Gabber';\n  return 'Speedcore';\n}\n\n/**\n * ビートタイムの配列から規則性を分析\n * @param beatTimes - ビートタイムの配列\n * @returns 規則性の分析結果\n */\nexport function analyzeBeatRegularity(beatTimes: number[]): {\n  averageInterval: number;\n  standardDeviation: number;\n  regularity: 'very_regular' | 'regular' | 'irregular' | 'very_irregular';\n} {\n  if (beatTimes.length < 2) {\n    return {\n      averageInterval: 0,\n      standardDeviation: 0,\n      regularity: 'very_irregular'\n    };\n  }\n  \n  // 間隔の計算\n  const intervals = [];\n  for (let i = 1; i < beatTimes.length; i++) {\n    intervals.push(beatTimes[i] - beatTimes[i - 1]);\n  }\n  \n  // 平均間隔\n  const averageInterval = intervals.reduce((sum, interval) => sum + interval, 0) / intervals.length;\n  \n  // 標準偏差\n  const variance = intervals.reduce((sum, interval) => {\n    return sum + Math.pow(interval - averageInterval, 2);\n  }, 0) / intervals.length;\n  const standardDeviation = Math.sqrt(variance);\n  \n  // 規則性の判定\n  const coefficientOfVariation = standardDeviation / averageInterval;\n  let regularity: 'very_regular' | 'regular' | 'irregular' | 'very_irregular';\n  \n  if (coefficientOfVariation < 0.05) {\n    regularity = 'very_regular';\n  } else if (coefficientOfVariation < 0.1) {\n    regularity = 'regular';\n  } else if (coefficientOfVariation < 0.2) {\n    regularity = 'irregular';\n  } else {\n    regularity = 'very_irregular';\n  }\n  \n  return {\n    averageInterval,\n    standardDeviation,\n    regularity\n  };\n}\n\n/**\n * オーディオファイルの再生時間からBPMを概算\n * @param duration - 音声ファイルの長さ（秒）\n * @param estimatedBeats - 推定されるビート数\n * @returns 概算BPM\n */\nexport function estimateBPMFromDuration(duration: number, estimatedBeats: number): number {\n  const beatsPerSecond = estimatedBeats / duration;\n  return Math.round(beatsPerSecond * 60);\n}\n\n/**\n * BPMの変更に合わせてエフェクトパラメータを調整\n * @param originalBPM - 元のBPM\n * @param newBPM - 新しいBPM\n * @param effectDuration - エフェクトの継続時間（秒）\n * @returns 調整されたエフェクト継続時間\n */\nexport function adjustEffectForBPM(originalBPM: number, newBPM: number, effectDuration: number): number {\n  const ratio = originalBPM / newBPM;\n  return effectDuration * ratio;\n}\n\n/**\n * ビートグリッドのスナップ距離を計算\n * @param pixelsPerSecond - 1秒あたりのピクセル数\n * @param bpm - Beats Per Minute\n * @param subdivisions - サブディビジョン（1, 2, 4, 8, 16）\n * @returns スナップ距離（ピクセル）\n */\nexport function calculateSnapDistance(pixelsPerSecond: number, bpm: number, subdivisions: number): number {\n  const beatInterval = 60 / bpm;\n  const subdivisionInterval = beatInterval / subdivisions;\n  return subdivisionInterval * pixelsPerSecond;\n}\n\n/**\n * 周波数解析結果から音楽の特徴を抽出\n * @param analysis - 音声解析結果\n * @returns 音楽の特徴\n */\nexport function extractMusicFeatures(analysis: AudioAnalysis): {\n  bassHeavy: boolean;\n  treblySound: boolean;\n  dynamicRange: 'low' | 'medium' | 'high';\n  brightness: number;\n} {\n  const bassEnergy = analysis.frequencyBands\n    .filter(band => ['BASS', 'SUB_BASS', 'KICK'].includes(band.name))\n    .reduce((sum, band) => sum + band.energy, 0) / 3;\n  \n  const trebleEnergy = analysis.frequencyBands\n    .filter(band => ['HIGHS', 'BRILLIANCE', 'PRESENCE'].includes(band.name))\n    .reduce((sum, band) => sum + band.energy, 0) / 3;\n  \n  const dynamicRange = analysis.peak - analysis.rms;\n  let dynamicRangeCategory: 'low' | 'medium' | 'high';\n  \n  if (dynamicRange < 0.3) {\n    dynamicRangeCategory = 'low';\n  } else if (dynamicRange < 0.6) {\n    dynamicRangeCategory = 'medium';\n  } else {\n    dynamicRangeCategory = 'high';\n  }\n  \n  return {\n    bassHeavy: bassEnergy > 0.6,\n    treblySound: trebleEnergy > 0.6,\n    dynamicRange: dynamicRangeCategory,\n    brightness: analysis.spectralCentroid\n  };\n}\n\n/**\n * デバッグ用：BPM解析結果を読みやすい形式で出力\n * @param analysis - BPM解析結果\n */\nexport function debugBPMAnalysis(analysis: BPMAnalysis): void {\n  console.group('🎵 BPM解析結果');\n  console.log(`BPM: ${analysis.bpm}`);\n  console.log(`信頼度: ${(analysis.confidence * 100).toFixed(1)}%`);\n  console.log(`ビート数: ${analysis.beatTimes.length}`);\n  console.log(`小節数: ${analysis.bars.length}`);\n  console.log(`拍子: ${analysis.timeSignature.numerator}/${analysis.timeSignature.denominator}`);\n  \n  const regularity = analyzeBeatRegularity(analysis.beatTimes);\n  console.log(`ビートの規則性: ${regularity.regularity}`);\n  console.log(`平均ビート間隔: ${regularity.averageInterval.toFixed(3)}秒`);\n  \n  const genre = guessGenreFromBPM(analysis.bpm);\n  console.log(`推測ジャンル: ${genre}`);\n  \n  console.groupEnd();\n}"